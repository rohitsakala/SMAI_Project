<p>I am inspired from this post:</p>  <p><a href="http://stackoverflow.com/questions/22760963/how-to-create-windows-service-from-perl-script-on-windows-7-64-bit/">source link</a> of How to Create Windows service from PERL script on Windows 7 64-bit</p>  <p>I do</p>  <pre><code>C:\Perl64\bin\perl.exe -I "C:\infoG\Create-Windows-service" "C:\infoG\Create-Windows-service\service.pl" --run </code></pre>  <p>The perl code of my script:</p>  <pre><code>use warnings; use strict; use File::ChangeNotify; use Switch; use File::Basename; use Text::CSV;  use Win32; use Win32::Daemon;  $| = 1;  my $watcher =     File::ChangeNotify-&gt;instantiate_watcher         ( directories =&gt; [ 'C:\infoG\Create-Windows-service' ],             filter  =&gt; qr/\.csv$/         );  main();  use constant SERVICE_NAME =&gt; 'Four01'; use constant SERVICE_DESC =&gt; 'dossier Four01';  sub main {     # Get command line argument - if none passed, use empty string     my $opt = shift (@ARGV) || "";      # Check command line argument     if ($opt =~ /^(-i|--install)$/i)     {         install_service(SERVICE_NAME, SERVICE_DESC);     }     elsif ($opt =~ /^(-r|--remove)$/i)     {         remove_service(SERVICE_NAME);     }     elsif ($opt =~ /^(--run)$/i)     {         # Redirect STDOUT and STDERR to a log file         # Derive the name of the file from the name of the program         # The log file will be in the scripts directory, with extension .log         my ($cwd,$bn,$ext) =             ( Win32::GetFullPathName($0) =~ /^(.*\\)(.*)\.(.*)$/ ) [0..2] ;         my $log = $cwd . $bn . ".log";          # Redirect STDOUT and STDERR to log file         open(STDOUT, "&gt;&gt; $log") or die "Couldn't open $log for appending: $!\n";         open(STDERR, "&gt;&amp;STDOUT");         # Autoflush, no buffering         $|=1;          # Register the events which the service responds to         Win32::Daemon::RegisterCallbacks( {             start       =&gt;  \&amp;Callback_Start,             running     =&gt;  \&amp;Callback_Running,             stop        =&gt;  \&amp;Callback_Stop,             pause       =&gt;  \&amp;Callback_Pause,             continue    =&gt;  \&amp;Callback_Continue,         } );         my %Context = (             last_state =&gt; SERVICE_STOPPED,             start_time =&gt; time(),         );         # Start the service passing in a context and indicating to callback         # using the "Running" event every 2000 milliseconds (2 seconds).         # NOTE: the StartService method with in 'callback mode' will block, in other         # words it won't return until the service has stopped, but the callbacks below         # will respond to the various events - START, STOP, PAUSE etc...         Win32::Daemon::StartService( \%Context, 2000 );          # Here the service has stopped         close STDERR; close STDOUT;     }     else     {         print "No valid options passed - nothing done\n";     } }  sub Callback_Running {     my( $Event, $Context ) = @_;      # Note that here you want to check that the state     # is indeed SERVICE_RUNNING. Even though the Running     # callback is called it could have done so before     # calling the "Start" callback.     if( SERVICE_RUNNING == Win32::Daemon::State() )     {         # ... process your main stuff here...         # ... note that here there is no need to         #     change the state          # For now just print hello to the STDOUT, which goes to the log file         print "Hello! Start demon\n";          $Context-&gt;{last_state} = SERVICE_RUNNING;         Win32::Daemon::State( SERVICE_RUNNING );          while ( my @events = $watcher-&gt;wait_for_events() ) {               print "new event\n";             for my $event ( @events ) {                  my $path_url = $event-&gt;path();                 my $ev = $event-&gt;type();                 print $path_url, ' - ', $ev, "\n";                 print $path_url, ' - ', $ev, "\n";                  my($filename, $dirs, $suffix) = fileparse($path_url);                 print "filename: ", $filename, ' - ',"dirs: ", $dirs, ' - ', "suffix: ", $suffix, "\n";                  my $file_out = "create.html";                  #"create", "modify", "delete", or "unknown".                  switch($ev){                     case "create"     {                          print "info: create\n";                          my ($ref_tab) = parce_csv($dirs,  $filename, $path_url);                         my (@tableau) = @{$ref_tab};                         #print "@$_\n" for @array;                         print "tableau: ---&gt;","\n";                         print "@$_\n" for @tableau;                         create_htm($dirs,  $file_out, $ref_tab);                     }                     case "modify"     {                          print "info: modify\n";                         my ($ref_tab) = parce_csv($dirs,  $filename);                         my (@tableau) = @{$ref_tab};                         #print "@$_\n" for @array;                         print "tableau: ---&gt;","\n";                         print "@$_\n" for @tableau;                         create_htm($dirs,  $file_out, $ref_tab);                     }                     case "delete"     { print "info: delete\n" }                     case "unknown"    { print "info: unknown\n" }                     else              { print "info: autre\n" }                 }             }         }     } }     sub Callback_Start {     my( $Event, $Context ) = @_;     # Initialization code     # ...do whatever you need to do to start...      print "Starting...\n";      $Context-&gt;{last_state} = SERVICE_RUNNING;     Win32::Daemon::State( SERVICE_RUNNING ); }  sub Callback_Pause {     my( $Event, $Context ) = @_;      print "Pausing...\n";      $Context-&gt;{last_state} = SERVICE_PAUSED;     Win32::Daemon::State( SERVICE_PAUSED ); }  sub Callback_Continue {     my( $Event, $Context ) = @_;      print "Continuing...\n";      $Context-&gt;{last_state} = SERVICE_RUNNING;     Win32::Daemon::State( SERVICE_RUNNING ); }  sub Callback_Stop {     my( $Event, $Context ) = @_;      print "Stopping...\n";      $watcher-&gt;reset();      $Context-&gt;{last_state} = SERVICE_STOPPED;     Win32::Daemon::State( SERVICE_STOPPED );      # We need to notify the Daemon that we want to stop callbacks and the service.     Win32::Daemon::StopService(); }  sub install_service {     my ($srv_name, $srv_desc) = @_;     my ($path, $parameters);      # Get the program's full filename, break it down into constituent parts     my $fn = Win32::GetFullPathName($0);     my ($cwd,$bn,$ext) = ( $fn =~ /^(.*\\)(.*)\.(.*)$/ ) [0..2] ;      # Determine service's path to executable based on file extension     if ($ext eq "pl")     {         # Source perl script - invoke perl interpreter         $path = "\"$^X\"";         # Parameters include extra @INC directories and perl script         # @INC directories must not end in \ otherwise perl hangs         my $inc = ($cwd =~ /^(.*?)[\\]?$/) [0];         # The command includes the --run switch needed in main()         $parameters = "-I " . "\"$inc\"" . " \"$fn\" --run";     }     elsif ($ext eq "exe")     {         # Compiled perl script - invoke the compiled script         $path = "\"$fn\"";         $parameters = "";     }     else     {         # Invalid file type?         die "Can not install service for $fn,         file extension $ext not supported\n";     }      # Populate the service configuration hash     # The hash is required by Win32::Daemon::CreateService     my %srv_config = (         name         =&gt; $srv_name,         display      =&gt; $srv_name,         path         =&gt; $path,         description  =&gt; $srv_desc,         parameters   =&gt; $parameters,         service_type =&gt; SERVICE_WIN32_OWN_PROCESS,         start_type   =&gt; SERVICE_AUTO_START,     );     # Install the service     if( Win32::Daemon::CreateService( \%srv_config ) )     {         print "Service installed successfully\n";     }     else     {         print "Failed to install service\n";     } }  sub remove_service {     my ($srv_name, $hostname) = @_;     $hostname ||= Win32::NodeName();     if ( Win32::Daemon::DeleteService ( $srv_name ) )     {         print "Service uninstalled successfully\n";     }     else     {         print "Failed to uninstall service\n";     } }  sub parce_csv {     my($folder_file, $my_file, $my_url) = @_;      my (@tableau2D);      print "sub parce_csv: ", ' - ',"folder_file: ", $folder_file, ' - ', "my_file: ", $my_file, "\n";     print "sub parce_csv: ", ' - ',"my_url: ", $my_url, "\n";      my $csv = Text::CSV-&gt;new({ sep_char =&gt; ';' });      my $file = $my_url or die "Need to get CSV file on the command line\n";      my $iter_ligne = 0;     open(my $data, '&lt;:utf8', $file) or die "Could not open '$file' $!\n";     while (my $line = &lt;$data&gt;) {          chomp $line;         if ($csv-&gt;parse($line)) {              my @fields = $csv-&gt;fields();              $tableau2D[$iter_ligne] = [ @fields ];              #$sum += $fields[2];             my $arrSize = @fields;             my $i = 0;             for my $field ( @fields ) {                  if ($i==($arrSize-1)) {                     print $field, "\n";                 }                 else {                     print $field, " - ";                 }                 $i++;             }          } else {             warn "Line could not be parsed: $line\n";         }          $iter_ligne++;         print "iter_ligne : ","$iter_ligne\n";      }     #print "$sum\n";      print "tableau int2D: ---&gt;","\n";     print "@$_\n" for @tableau2D;      return \@tableau2D; }  sub create_htm {     my(@args) = @_;      my $cmdString = $args[0];     my $file=$args[1];     my $ref = $args[2];     my @tab = @$ref;          print "tableau create_htm: ---&gt;","\n";     print "@$_\n" for @tab;      chdir($cmdString)|| die "Error: could not '$cmdString'";      if (-e $file) #if the file exists      {          print "re-ecriture HLM\n";     }      open(my $FILE, "&gt;$file") or die "Cannot open $file: $!"; ## &gt;&gt; means +append to the end of file.       my $re = $file;      print $FILE '&lt;!DOCTYPE html&gt;';     print $FILE '&lt;html&gt;';     print $FILE '&lt;head&gt;';     print $FILE '   &lt;meta name="robots" content="noindex,nofollow"&gt;';     print $FILE '   &lt;title&gt;HTML auto&lt;/title&gt;';     print $FILE '&lt;script type="text/javascript"&gt;';     print $FILE 'var refreshTime= 2*2;';     #rafr√©chissement     print $FILE '    var foo = document.write(\'&lt;meta http-equiv="refresh" content="\'+refreshTime+\';url=',$re,' "&gt;\');';     print $FILE '&lt;/script&gt;';     print $FILE '&lt;/head&gt;';     print $FILE '&lt;body&gt;';      print $FILE '&lt;h1&gt;My First Heading&lt;/h1&gt;';      print $FILE '&lt;p&gt;My first paragraph.&lt;/p&gt;';      print $FILE '&lt;table style="width:100%"&gt;';     foreach my $row (@tab) {         print $FILE '&lt;tr&gt;';         foreach my $element (@$row) {             print $FILE '&lt;td&gt;';             print $FILE $element;             print $FILE '&lt;/td&gt;';         }         print $FILE '&lt;/tr&gt;';     }     print $FILE '&lt;/table&gt;';      print $FILE '&lt;/body&gt;';     print $FILE '&lt;/html&gt;';        close($FILE);       print "Your html has been created";  } </code></pre>  <p>Then I will stop my service on the panel of Windows services, he told me that the time was too long to stop the process, and then when I will start or restart the service the boxes are gray and inactive. I must kill manually the process of perl with the task manager of Windows. So I can start again the service.</p>  <p>What must I do for having the possibility to manage the service on the control panel of services on Windows?</p>  <p>Many thanks for your answer.</p>