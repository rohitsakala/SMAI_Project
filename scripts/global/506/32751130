<p>Here is what I have mustered up:</p>  <p><pre><code>from graphics import * from random import * from math import *</p>  <p>class Ball(Circle):     def <strong>init</strong>(self, win_width, win_high, point, r, vel1, vel2):         Circle.<strong>init</strong>(self, point, r)</p>  <pre><code>    self.width = win_width     self.high = win_high      self.vecti1 = vel1     self.vecti2 = vel2   def collide_wall(self):     bound1 = self.getP1()     bound2 = self.getP2()      if (bound2.y &gt;= self.width):                     self.vecti2 = -self.vecti2         self.move(0, -1)     if (bound2.x &gt;= self.high):         self.vecti1 = -self.vecti1         self.move(-1, 0)     if (bound1.x &lt;= 0):         self.vecti1 = -self.vecti1         self.move(1, 0)     if (bound2.y &lt;= 0):                     self.vecti2 = -self.vecti2         self.move(0, 1)  def ball_collision(self, cir2):     radius = self.getRadius()     radius2 = cir2.getRadius()      bound1 = self.getP1()           bound3 = cir2.getP1()       center1 = Point(radius + bound1.x,radius + bound1.y)     center2 = Point(radius2 + bound3.x,radius2 + bound3.y)      centerx = center2.getX() - center1.getX()     centery = center2.getY() - center1.getY()      distance = sqrt((centerx * centerx) + (centery * centery))      if (distance &lt;= (radius + radius2)):         xdistance = abs(center1.getX() - center2.getX())         ydistance = abs(center1.getY() - center2.getY())          if (xdistance &lt;= ydistance):             if ((self.vecti2 &gt; 0 &amp; bound1.y &lt; bound3.y) | (self.vecti2 &lt; 0 &amp; bound1.y &gt; bound3.y)):                 self.vecti2 = -self.vecti2               if ((cir2.vecti2 &gt; 0 &amp; bound3.y &lt; bound1.y) | (cir2.vecti2 &lt; 0 &amp; bound3.y &gt; bound1.y)):                 cir2.vecti2 = -cir2.vecti2            elif (xdistance &gt; ydistance):             if ((self.vecti1 &gt; 0 &amp; bound1.x &lt; bound3.x) | (self.vecti1 &lt; 0 &amp; bound1.x &gt; bound3.x)):                 self.vecti1 = -self.vecti1              if ((cir2.vecti1 &gt; 0 &amp; bound3.x &lt; bound1.x) | (cir2.vecti1 &lt; 0 &amp; bound3.x &gt; bound1.x)):                 cir2.vecti1 = -cir2.vecti1 </code></pre>  <p>def main():     win = GraphWin("Ball screensaver", 700,700)</p>  <pre><code>velo1 = 4 velo2 = 3 velo3 = -4 velo4 = -3  cir1 = Ball(win.getWidth(),win.getHeight(),Point(50,50), 20, velo1, velo2)  cir1.setOutline("red") cir1.setFill("red") cir1.draw(win)  cir2 = Ball(win.getWidth(),win.getHeight(),Point(200,200), 20, velo3, velo4) cir2.setOutline("blue") cir2.setFill("blue") cir2.draw(win)   while(True):     cir1.move(cir1.vecti1, cir1.vecti2)     cir2.move(cir2.vecti1, cir2.vecti2)     time.sleep(.010)     cir1.collide_wall()     cir2.collide_wall()      cir1.ball_collision(cir2)     #cir2.ball_collision(cir1) </code></pre>  <p>main()</p>  <p></pre></code></p>  <p>Ok so here is the problem. This Math is not working correctly at all. Sometimes it works perfectly sometimes one ball overpowers the other ball or they don't react like a ball collision should. I am racking my brain trying to figure out what the problem is but I feel I am too close to the project at the moment to see it. Any help would be appreciated.</p>